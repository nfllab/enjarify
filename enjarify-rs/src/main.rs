// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use std::env;
use std::fs::File;
use std::fs::OpenOptions;
use std::io::prelude::*;
use std::mem;
use std::path::Path;
use std::panic;
use std::str;

#[macro_use]
extern crate lazy_static;

extern crate futures;
use futures::Future;
extern crate futures_cpupool;
use futures_cpupool::CpuPool;

extern crate getopts;
extern crate zip;
use zip::CompressionMethod::{Deflated,Stored};

mod byteio;
mod dalvik;
mod dalvikformats;
mod dex;
mod error;
mod flags;
mod hashtests;
mod jvm;
mod mutf8;
mod runtests;
mod pack;
mod strings;
mod treelist;
mod typeinference;

use strings::*;
use jvm::optimization::options::Options;

fn read<P: AsRef<Path>>(path: P) -> BString {
    let mut data = Vec::new();
    let mut f = File::open(path).unwrap();
    f.read_to_end(&mut data).unwrap();
    data
}

fn read_jar(fname: &str) -> Vec<(String, BString)> {
    let mut items = Vec::new();
    let mut archive = zip::ZipArchive::new(File::open(fname).unwrap()).unwrap();
    for i in 0..archive.len() {
        let mut zf = archive.by_index(i).unwrap();
        let mut data = Vec::new();
        zf.read_to_end(&mut data).unwrap();
        items.push((zf.name().to_string(), data));
    }
    items.sort();
    items
}

pub fn write_to_jar(fname: &str, classes: Vec<(String, BString)>) {
    let mut archive = zip::ZipWriter::new(File::create(fname).unwrap());
    let notime = zip::DateTime::from_date_and_time(1980, 1, 1, 0, 0, 0).unwrap();
    let options = zip::write::FileOptions::default().last_modified_time(notime).unix_permissions(0o775);
    for (unicode_name, data) in classes.into_iter() {
        // Don't bother compressing small files
        let method = if data.len() > 10000 {Deflated} else {Stored};
        archive.start_file(unicode_name, options.compression_method(method)).unwrap();
        archive.write_all(&data).unwrap();
    }
}

fn translate(pool: &CpuPool, opts: Options, dexes: &[BString]) -> Vec<(String, Result<BString, String>)> {
    let mut results = Vec::new();

    for data in dexes.iter() {
        let dex = dex::DexFile::new(data);
        let dex_classes = dex.parse_classes();
        // futures_cpupool, y u no scoped threads?
        let unsafe_classes: Vec<dex::DexClass<'static>> = unsafe{ mem::transmute(dex_classes) };

        let result_futures: Vec<_> = unsafe_classes.into_iter().map(|cls| {
            pool.spawn_fn(move || {
                let unicode_name = mutf8::decode(cls.name).into_owned() + ".class";

                let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {
                    Ok(jvm::writeclass::to_class_file(&cls, opts))
                })).unwrap_or_else(|err| {
                    let error_string = err.downcast::<String>().map(|b| *b).or_else(|err| {
                        err.downcast::<&'static str>().map(|s| s.to_string())
                    }).unwrap_or("panic with unknown type".to_string());
                    Err(error_string)
                });
                let res: Result<_, ()> = Ok((unicode_name, res));
                res
            })
        }).collect();
        results.extend(result_futures.into_iter().map(|fut| fut.wait().unwrap()));
    }
    results
}

fn print_usage(program: &str, opts: getopts::Options) {
    let brief = format!("Usage: {} [options]", program);
    print!("{}", opts.usage(&brief));
}

fn main() {
    error::set_hook();
    let args: Vec<String> = env::args().collect();
    let program = args[0].clone();

    let mut opts = getopts::Options::new();
    opts.optopt("o", "output", "Output .jar file. Default is [input-filename]-enjarify.jar.", "FILE");
    opts.optopt("i", "input", "Input .apk or .dex file.", "FILE");
    opts.optflag("f", "force", "Force overwrite. If output file already exists, this option is required to overwrite.");
    opts.optflag("", "fast", "Speed up translation at the expense of generated bytecode being less readable.");
    opts.optflag("", "runtests", "");
    opts.optflag("", "hashtests", "");
    opts.optflag("h", "help", "Print this help message and exit.");
    let matches = opts.parse(&args[1..]).unwrap();

    if matches.opt_present("help") {
        print_usage(&program, opts);
        return;
    }

    if matches.opt_present("runtests") { runtests::main(); return; }
    if matches.opt_present("hashtests") { hashtests::main(); return; }

    if !matches.opt_present("input") {
        print_usage(&program, opts);
        return;
    }
    let inputfile = matches.opt_str("input").unwrap();
    let dexes: Vec<_> = if inputfile.to_lowercase().ends_with(".apk") {
        let pairs = read_jar(&inputfile);
        pairs.into_iter().filter(|&(ref name, _)| name.ends_with(".dex")).map(|(_, data)| data).collect()
    } else {
        vec![read(&inputfile)]
    };

    let outname = matches.opt_str("output").unwrap_or_else(|| {
        let ind = inputfile.rfind("/").map(|x| x+1).unwrap_or(0);
        let s = inputfile.split_at(ind).1;
        let ind = s.rfind(".").unwrap_or(s.len());
        let s = s.split_at(ind).0;
        s.to_string() + "-enjarify.jar"
    });

    {OpenOptions::new().write(true).create(true).create_new(!matches.opt_present("force")).open(&outname).expect("Error, output file already exists and -f was not specified. To overwrite the output file, pass -f\n")};

    let pool = CpuPool::new_num_cpus();
    let translate_options = if matches.opt_present("fast") { Options::none() } else { Options::pretty() };
    let results = translate(&pool, translate_options, &dexes);

    let mut classes = Vec::with_capacity(results.len());
    let mut errors = Vec::new();
    for (name, res) in results.into_iter() {
        match res {
            Ok(data) => classes.push((name, data)),
            Err(error) => errors.push((name, error)),
        }
    }

    let clen = classes.len();
    write_to_jar(&outname, classes);

    println!("Output written to {}", outname);

    for &(ref name, ref error) in errors.iter() {
        println!("{} {}", name, error);
    }
    println!("{} classes translated successfully, {} classes had errors", clen, errors.len());
}
